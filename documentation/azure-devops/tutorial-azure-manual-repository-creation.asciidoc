:imagesdir: ./images/tutorial-azure-manual-repository-creation

= How to create your repository

In this documentation we will see how repositories works on Azure, we will see how to create one when it is a brand new project,  but also how to do it when your project already has a repository +

All the actions will be done manually with the web interface, if you want to use command line or a script that automatize these steps, check this documentation: link:setup-repository-script.asciidoc[]

== I. Your project is new and your repository is empty

When you create a new project, an empty repository is created. +

To access it, click on `Repos` on the left panel of the home page and will get this page:


image:select_repo2.png[] | image:2_empty_repo.png[800,600]

Now that you are on this page, 4 possibilities are available.


  A: You can clone the empty repository on you computer to start the modification.
  B: You can push an existing local repository to your project.

  C: You can import an existing online repository with the url.

  D: You can initialize your repository with a 'main' branch.


=== A. Clone it to your computer

image:
You can clone the repository on your computer to create content inside it, in this example we will use Git bash (of course Git bash is not the only client you can use).

First you need to copy the URL of the repository.

Then open a Git bash prompt in the folder you want, and use the `git clone <URL>` command. +
image:2_1_0.PNG[]

```
$ git clone https://organisation@dev.azure.com/organisation/project/_git/repository
Cloning into 'repository'...
warning: You appear to have cloned an empty repository.
```

We can notice there is a warning about the repository being empty. If you enter in it, it will automatically be on a branch called *master*, this branch actually only exists on your local computer. +
We can now commit and push our changes with: +
`git add -A` will add all modification to next commit. +
`git commit -m "<message>"` will commit your changes to your local branch. +
`git push` will push your local branch and the commits you have done on the remote repository. +
example: +
(here we just created a text file *test*)
```
user@computer MINGW64 C:/path/to/folder/repository (master)
$ git status #not mandatory, we just use it in the example to show modifications
On branch master

No commits yet

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        test

nothing added to commit but untracked files present (use "git add" to track)

user@computer MINGW64 C:/path/to/folder/repository (master)
$ git add -A

user@computer MINGW64 C:/path/to/folder/repository (master)
$ git commit -m "test"
[master (root-commit) cc45cc5] test
 1 file changed, 1 insertion(+)
 create mode 100644 test

user@computer MINGW64 C:/path/to/folder/repository (master)
$ git push
Enumerating objects: 3, done.
Counting objects: 100% (3/3), done.
Writing objects: 100% (3/3), 219 bytes | 219.00 KiB/s, done.
Total 3 (delta 0), reused 0 (delta 0), pack-reused 0
remote: Analyzing objects... (3/3) (5 ms)
remote: Storing packfile... done (88 ms)
remote: Storing index... done (51 ms)
To https://organisation@dev.azure.com/organisation/project/_git/repository
 * [new branch]      master -> master
```

Once it is pushed, we can now see that the branch and its content are available on Azure.

image::2_1_3_azure_repo_after_push.PNG[]

=== B. Push an existing repository from command line

image::2_2_0.PNG[]

if you have a local Git directory, you can push it as your Azure repository. (this works only if you have never pushed this repository online)

==== 1. initialize your folder as Git repository (if your folder is not a Git repository, if it is go to 2.)

First let's see how to create a local Git repository. +
If you have a folder with all your code already but that folder is not a Git repository, example:

image::2_2_1_directory.PNG[]

open Git command line at the root of this folder (in this example it will be Git bash)

`cd <root_of_your_folder>`  +
example:

```
$ cd test_azureB/
# We use ls to see the content of our folder (this command is just for showing the folder is not empty in our example)
$ ls
code.java
```


Use the `git init .` command to convert your simple folder into a Git repository. +
example:
```
$ git init .
Initialized empty Git repository in C:/path/to/folder/test_azureB/.git/
```

Now you have a local Git repository. You can now add every files and folders in your first commit:
`git add -A` it will select all the files inside your Git repository +
`git commit -m "first commit"` it will commit your files (-m is for adding a message to your commit)+
example:

```
$ git add -A
$ git commit -m "first commit"
[master (root-commit) 0badb76] first commit
 1 file changed, 1 insertion(+)
 create mode 100644 code.java
```

Your folder has now been converted into a Git repository and you have your first branch.


==== 2. Push it to your Azure project

You can use the command shown on the Azure interface: +
`git remote add origin <your_project_url>` this will create the repository remotely +
`git push -u origin --all` this will push your branches to that remote repository +
example:
```
$ git remote add origin https://organisation@dev.azure.com/organisation/project/_git/repository
$ git push -u origin --all

Enumerating objects: 3, done.
Counting objects: 100% (3/3), done.
Writing objects: 100% (3/3), 230 bytes | 230.00 KiB/s, done.
Total 3 (delta 0), reused 0 (delta 0), pack-reused 0
remote: Analyzing objects... (3/3) (7 ms)
remote: Storing packfile... done (58 ms)
remote: Storing index... done (52 ms)
To https://organisation@dev.azure.com/organisation/project/_git/repository
 * [new branch]      master -> master
Branch 'master' set up to track remote branch 'master' from 'origin'.

```

You can now see on your Azure project that the repository is available

image::2_2_6_repon_end.PNG[]


=== C. Import a existing Git repository

image::2_3_0.PNG[]

You can import the content of an existing Git repository.

WARNING: As it just imports the content, modifications made on your Azure repository will not affect the initial Git repository you imported.


First you need to get the url of your repository (here is an example with a repository from Github).


image::2_3_1_github_repo.PNG[]

Then  import it in your Azure project.


image::2_3_2_import_to_azure.png[]

You can now see the that all your branches and files have been imported.


image::2_3_3_repository_after.PNG[]

=== D. Initialize your repository

image::2_4_0.PNG[]

You just need to click on *Initialize*.

You decide to add an `README` file or entries to the `gitignore` file

The `README` file allows you to display information about the repository when you open it (see next picture). +
The `gitignore` file list all type of file that needs to be ignore when committing, for example if there are artefacts generated by builds you do not want to commit.


NOTE: You can modify/delete the two files after initializing your repository.


Once your repository is initialized, it will look like this:

image::2_4_1.png[]



== II. A repository already exists but you want to create a new one

When a repository already exists you have 3 choices to create a new one:

  A. Create the repository and initialize it (the result is equivalent to I.D.)
  B. Create an empty repository
  C. Import an already existed repository (the result is equivalent to I.C.)


=== A. and B.

On top of your page there is the path of the repository you are browsing. click on it and the option 'New repository'.

image::P2_new_repo.png[]

Then you can choose the name of your repository and if you want to initialize it.

image::P2_A_1_create.PNG[]

If you tick the 'Add a README' box, it will create your repository and initialize it with a main branch exactly as seen in I.D.

If you untick this box, it will create an empty repository, in this case you can follow the steps of A, B, C or D of part I. because your repository will be in the same state as what we saw previously.


=== C. Import an already existing Git repository

Instead of 'New repository' you can choose 'Import a repository'.

image:P2_B_0_import.png[]

Then you just need to put the URL of the repository you want to import and choose the name of the repository that will be created.


image:P2_C_URL_name.PNG[]

== III. Branches and policies

Now that you have created a repository, you may need to set a workflow and policies for your branches.

=== A. Branches

==== 1. Create a branch

To create a branch, on the left menu, select 'Repos' > 'Branches'.

image::P3_A_1_1_menu_branches.png[]

On the top right corner, press the 'New branch' button.

image::P3_A_1_2_new_branche.png[]

You can now choose how your branch is gonna be called and from which branch you create it.

image::P3_A_1_3_name_branch.PNG[]

==== 2. Workflow

We advice you to follow this workflow for your branches.

You have 4 type of branches:

- *develop* (one branch): This is the branch containing all finished development waiting for validation, everytime you work on a new feature (or bug fix), you need to create a new branch, this branch must be created from *develop*, once your development is over, you can merge it into *develop* where validation tests will play on it. If these tests are succesful, *develop* is merged into *master* +
- *master* (one branch): This branch contains every validated development ready to be released. This is from this branch that we create releases. +
- *Feature branches*: As described above, you need to create a branch from *develop*, once your work is over, you merge it into *develop*. +
- *Release Branches*: They contain a full version of the application, and as explained above, you should create them from master.

NOTE: You should never commit directly on *develop* or *master*, modifications on *develop* should only come from merge of feature branches and modifications on *master* should only come from merge of *develop*.

=== B. Branch policies

==== 1. Create/modify policies

Branches policies are important because it allows you to set rules for commiting in branches. These rules are useful to avoid messing with the commit history so that in case of problem it is clean to make analysis easier, it can also allow only specific user to validate merge request to secure your branches.

To access the policy of a branch, go back to the list of branches ('Repos' > 'Branches' on the left menu). +
Then click on the 3 dots on the line of your branch to display more options and select 'Branch policies'

image::P3_B_1_1_menu_branches_for_policy.png[]

This menu will appear:

image::P3_B_1_2_policy_menu.png[]

Here we are gonna to talk only about merge limits, but if you want detailed information about every options: +
https://docs.microsoft.com/en-us/azure/devops/repos/git/branch-policies?view=azure-devops&tabs=browser

==== 2. Limit merge type

On the menu that appears previously, you can activate *Limit merge types*, you can choose to block/allow 4 types of merge.

- Basic merge (no fast-forward): creates a merge commit in the target whose parents are the target and source branches.
- Rebase and fast-forward: creates a linear history by replaying source commits onto the target branch with no merge commit.
- Squash merge: creates a linear history with a single commit in the target branch with the changes from the source branch. Learn more about squash merging and how it affects your branch history
- Rebase with merge commit: replays the source commits onto the target and still creates a merge commit.

Source: https://docs.microsoft.com/en-us/azure/devops/repos/git/branch-policies?view=azure-devops&tabs=browser

We advice you to choose these parameters for your branches:

===== master

image::P3_B_2_1_master_policy.PNG[]

===== develop

image::P3_B_2_2_develop_policy.PNG[]

We do not advice you to allow merge that will not create a merge commit on your branches, because thanks to that merge commit you can easily undo your merge.
