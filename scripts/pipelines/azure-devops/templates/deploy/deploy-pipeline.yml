trigger:
  branches:
    include:
    - '*'

resources:
  pipelines:
  - pipeline: 'package-Pipeline'
    source: '<@package-pipeline-name@>'
    trigger:
      branches:
        include:
        - releases/*
        - develop
        - feature/*
        exclude:
        - master

variables:
- group: registry_info  
- group: AWS_Credentials 
  
pool:
  vmImage: ubuntu-latest

jobs:
- job: Deploy_to_AKS
  condition: eq(variables.deployCluster, 'AKS')
  variables:
  - group: aks-variables # DNS available for this job
  steps:
  - task: DownloadPipelineArtifact@2
    condition: eq(variables.deployCluster, 'AKS')
    displayName: "Download AKS Kubeconfig"
    inputs:
      source: 'specific'
      project: '$(System.TeamProject)'
      pipeline: '$(aksProvisionPipelineName)'
      runVersion: 'latest'
      downloadPath: '$(Pipeline.Workspace)' 
    
  - task: Bash@3
    condition: eq(variables.deployCluster, 'AKS')
    displayName: "Deploy app to AKS" 
    inputs:
      targetType: 'inline'
      script: |
        # Add image name and ingress DNS name.
        export image=$(imagename) dns=$(dns_name)
        yq eval '.spec.template.spec.containers[0].image = "'$image'"' -i $(Build.Repository.LocalPath)/$(deployFiles)/*-deployment.yaml 
        yq eval '.spec.rules[0].host = "'$dns'"' -i $(Build.Repository.LocalPath)/$(deployFiles)/ingress.yaml
        # Create namespace in AKS cluster.
        kubectl create namespace $(k8sNamespace) --kubeconfig $(Pipeline.Workspace)/kubeconfig/kubeconfig
        # Apply manifest files.
        kubectl apply -f $(Build.Repository.LocalPath)/$(deployFiles) --namespace=$(k8sNamespace) --kubeconfig $(Pipeline.Workspace)/kubeconfig/kubeconfig

  - task: Bash@3
    condition: and(eq(variables.deployCluster, 'AKS'), ne(variables.secretsName, ''))
    displayName: 'create secrets for AKS'
    inputs:
      targetType: 'inline'
      script: | 
        #Command to create secrets to pull image from private registry.
        kubectl delete secret $(secretsName) --namespace=$(k8sNamespace) --kubeconfig $(Pipeline.Workspace)/kubeconfig/kubeconfig
        # create secrets for private registry.
        kubectl create secret docker-registry $(secretsName) \
            --docker-server=$(registry) \
            --docker-username=$(docker_username) \
            --docker-password=$(docker_password) \
            --namespace=$(k8sNamespace) \
            --kubeconfig $(Pipeline.Workspace)/kubeconfig/kubeconfig 
        # export secrets name and add secrets into deployment file.
        export secrets=$(secretsName) 
        yq e '.spec.template.spec."imagePullSecrets"=[{"name":"secrets"}]' -i $(Build.Repository.LocalPath)/$(deployFiles)/*-deployment.yaml 
        yq e '.spec.template.spec.imagePullSecrets[0].name = "'$secrets'"' -i $(Build.Repository.LocalPath)/$(deployFiles)/*-deployment.yaml 
        # Apply the changes.
        kubectl apply -f $(Build.Repository.LocalPath)/$(deployFiles)/*-deployment.yaml --namespace=$(k8sNamespace) --kubeconfig $(Pipeline.Workspace)/kubeconfig/kubeconfig

- job: Deploy_to_EKS
  condition: eq(variables.deployCluster, 'EKS')
  variables:
  - group: eks_variables # DNS available for this job
  steps:
  - task: Bash@3
    condition: eq(variables.deployCluster, 'EKS')
    displayName: Deploy app to EKS
    inputs:
      targetType: 'inline'
      script: |
        # connecting to EKS cluster using accesskey and secrets key, Update kubeconfig context.
        aws configure set aws_access_key_id $(ACCESS_KEY)
        aws configure set aws_secret_access_key $(SECRET_KEY)
        aws eks update-kubeconfig --name $(CLUSTER_NAME) --region $(REGION)
        # Add image name and ingress DNS name.
        export image=$(imagename) dns=$(dns_name)
        yq eval '.spec.template.spec.containers[0].image = "'$image'"' -i $(Build.Repository.LocalPath)/$(deployFiles)/*-deployment.yaml 
        yq eval '.spec.rules[0].host = "'$dns'"' -i $(Build.Repository.LocalPath)/$(deployFiles)/ingress.yaml
        # Create namespace in EKS cluster.
        kubectl create namespace $(k8sNamespace) 
        # Apply manifest files.
        kubectl apply -f $(Build.Repository.LocalPath)/$(deployFiles) --namespace=$(k8sNamespace) 
        
  - task: Bash@3
    condition: and(eq(variables.deployCluster, 'EKS'), ne(variables.secretsName, ''))
    displayName: 'create secrets for EKS'
    inputs:
      targetType: 'inline'
      script: | 
        #Command to create secrets to pull image from private registry.
        kubectl delete secret $(secretsName) --namespace=$(k8sNamespace) 
        # create secrets for private registry.
        kubectl create secret docker-registry $(secretsName) \
          --docker-server=$(registry) \
          --docker-username=$(aws_access_key) \
          --docker-password=$(aws_secret_access_key) \
          --namespace=$(k8sNamespace) 
        # export secrets name and add secrets into deployment file.
        export secrets=$(secretsName) 
        yq e '.spec.template.spec."imagePullSecrets"=[{"name":"secrets"}]' -i $(Build.Repository.LocalPath)/$(deployFiles)/*-deployment.yaml 
        yq e '.spec.template.spec.imagePullSecrets[0].name = "'$secrets'"' -i $(Build.Repository.LocalPath)/$(deployFiles)/*-deployment.yaml 
        # Apply the changes.
        kubectl apply -f $(Build.Repository.LocalPath)/$(deployFiles)/*-deployment.yaml --namespace=$(k8sNamespace)
           


